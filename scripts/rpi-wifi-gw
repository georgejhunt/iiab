#!/bin/bash -x
# Create a new SD card with specified download (1st param) onto /dev/sda

# use raspi-config for as much as possible
if [ -f /usr/bin/raspi-config ]; then
   cp /usr/bin/raspi-config /root/modified-raspi-config
   sed -i -e 's/INTERACTIVE=True/INTERACTIVE=False/' /root/modified-raspi-config
else
   echo "raspi-config is missing. Is this a raspberry pi?"
   exit 1
fi
if [ $(id -u) -ne 0 ];then
   echo Please run as root
   exit 1
fi

# Download the requested raspbian image
if [ $# -lt 3 ];then
   echo Please specify the url of the Raspbian to download, wifi ssid and password
   exit 1
else
   # maybe it has been previously downloaded 
   BASENAME=$(basename $1)
   if [ -f /home/pi/Downloads/$BASENAME ];then
      echo "$1 already present...skipping download"
   else
      wget -P /home/pi/Downloads $1
   fi
fi
fdisk -l /dev/sda
read -p "Does this look like the target SD card that you want to overwrite?" ans
case $ans in
'y'|'Y'|'yes'|'Yes')
   ;;
*)
   echo "Overwrite not confirmed...exiting"
   exit 1
   ;;
esac

# Use ssh file on boot partition to skip writing to the SD card
umount /dev/sda1
NEWBOOT=/mnt/sda1
mkdir -p $NEWBOOT
mount /dev/sda1 $NEWBOOT

if [ -f $NEWBOOT/ssh ]; then
   echo Skipping writting of the SD card because ssh in boot partition exists
   echo If this is not what you, please remove ssh and try again.
   #exit 0
else
   # Copy the OS to the SD card
   unzip /home/pi/Downloads/$BASENAME | dd of=/dev/sda status=progress conv=fsync
fi

# automatic mounting is unpredictable 
umount /dev/sda2
mkdir -p /mnt/sda2
NEWROOT=/mnt/sda2
mount /dev/sda2 $NEWROOT

# Put an empty file in boot partition to enable SSH server in Raspbian
touch $NEWBOOT/ssh

# list of virtual filesystems and additional config files
ARGS="dev dev/pts proc sys etc/resolv.conf /var/run/ root"
# mount the virtual filesystems & resolv.conf to enable the network
for i in $ARGS; do
  mount --bind /$i $NEWROOT/$i
done

cat <<CHROOTEOF > $NEWROOT/tasks
#!/bin/bash -x
# tasks executed in a chroot to split wifi for both upstream and downstream

# haveged adds entropy (randomness for hostapd)
apt-get install iptables dnsmasq hostapd haveged

# wpa_supplicant.conf
cat <<EOF > /etc/wpa_supplicant/wpa_supplicant.conf
# Generated by IIAB
# /etc/wpa_supplicant/wpa_supplicant.conf
country=US
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
  ssid="$2"
  psk="$3"
}
EOF

# hostapdstart script runs from rc.local
cat <<EOF > /usr/local/bin/hostapdstart
#!/bin/bash

      # need to find out which channel is used upstream
      wpa_supplicant -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf &
      sleep 3
      CHANNEL=\$(iw wlan0 info|grep channel|cut -d' ' -f2)
      echo \$CHANNEL
      /usr/bin/killall wpa_supplicant
      /sbin/iw dev wlan0 interface add wlan0_ap type __ap

      # need unique MAC, so change mfg field, and pick 3 arbitrary octets
      /sbin/ip link set wlan0 address b8:27:99:12:34:56
      /sbin/ifup wlan0_ap
      systemctl restart dnsmasq.service
      sysctl net.ipv4.ip_forward=1

      # get the channel that is in use -- supplied by upstream wifi
      if [ ! -z "\$CHANNEL" ]; then
         sed -i -e "s/^channel.*/channel=\$CHANNEL /" /etc/hostapd/hostapd.conf
      fi
      systemctl restart hostapd.service
      sleep 5
      ip link set dev wlan0 promisc on
EOF

chmod 755 /usr/local/bin/hostapdstart

# insert the hostapdstart script from /etc/rc.local
cat /etc/rc.local | grep hostapdstart
if [ \$? -ne 0 ]; then
  sed -i '/^ *exit/i \
/usr/local/bin/hostapdstart' /etc/rc.local
fi

# put netwoking files
cat <<EOF > /etc/network/interfaces.d/station
# Generated by IIAB
# /etc/network/interfaces.d/station
allow-hotplug wlan0
iface wlan0 inet manual
conf /etc/wpa_supplicant/wpa_supplicant.conf
EOF

cat <<EOF > /etc/network/interfaces.d/access-point
# Generated by IIAB
# /etc/network/interfaces.d/access-point in cooperation with hostapd
auto wlan0_ap
iface wlan0_ap inet static
address 172.18.96.1
netmask 255.255.224.0
EOF

cat <<EOF > /etc/hostapd/hostapd.conf
# Generated by IIAB
# /etc/hostapd/hostapd.conf
interface=wlan0_ap
ssid=APandClient
hw_mode=g
channel=6
macaddr_acl=0
country_code=US
ieee80211d=1
EOF

# create one backup of file we are about to overwrite
if [ ! -f /etc/wpa_supplicant/wpa_supplicant.conf.bak ];then
   cp /etc/wpa_supplicant/wpa_supplicant.conf \
       /etc/wpa_supplicant/wpa_supplicant.conf.bak
fi

# Do the same for dnsmasq
# create one backup of file we are about to overwrite
if [ ! -f /etc/dnsmasq.conf.bak ];then
   cp /etc/dnsmasq.conf  /etc/dnsmasq.conf.bak
fi

cat <<EOF > /etc/dnsmasq.conf
# Generated by IIAB

# If you want dnsmasq to listen for DHCP and DNS requests only on
# specified interfaces (and the loopback) give the name of the
# interface (eg eth0) here.
# Repeat the line for more than one interface.
interface=lo
interface=wlan0_ap

# Uncomment this to enable the integrated DHCP server, you need
# to supply the range of addresses available for lease and optionally
# a lease time. If you have more than one network, you will need to
# repeat this for each network on which you want to supply DHCP
# service.
dhcp-range=172.18.100.0,172.18.126.254,12h

# Delays sending DHCPOFFER and proxydhcp replies for at least the specified number of seconds.
dhcp-reply-delay=2

EOF

# dnsmasq uses /etc/hosts to populate it's own name cache
# so put box.lan in hosts
cat /etc/hosts|grep "-172.18.96.1" > /dev/null
if [ \$? -ne 0 ]; then
	echo "172.18.96.1     box.lan box" >> /etc/hosts
fi

# Do the same for dhcpcd.conf
# create one backup of file we are about to overwrite
if [ ! -f /etc/dhcpcd.conf.bak ];then
   cp /etc/dhcpcd.conf  /etc/dhcpcd.conf.bak
fi

# dhcpcd needs some values also
cat <<EOF > /etc/dhcpcd.conf
# Generated by IIAB

# A sample configuration for dhcpcd.
# See dhcpcd.conf(5) for details.

# Allow users of this group to interact with dhcpcd via the control socket.
#controlgroup wheel

# Inform the DHCP server of our hostname for DDNS.
hostname box

# Use the hardware address of the interface for the Client ID.
clientid
# or
# Use the same DUID + IAID as set in DHCPv6 for DHCPv4 ClientID as per RFC4361.
# Some non-RFC compliant DHCP servers do not reply with this set.
# In this case, comment out duid and enable clientid above.
#duid

# Persist interface configuration when dhcpcd exits.
persistent

# Rapid commit support.
# Safe to enable by default because it requires the equivalent option set
# on the server to actually work.
option rapid_commit

# A list of options to request from the DHCP server.
option domain_name_servers, domain_name, domain_search, host_name
option classless_static_routes
# Most distributions have NTP support.
option ntp_servers
# Respect the network MTU. This is applied to DHCP routes.
option interface_mtu

# A ServerID is required by RFC2131.
require dhcp_server_identifier

# Generate Stable Private IPv6 Addresses instead of hardware based ones
slaac private
denyinterfaces wlan0_ap
# Example static IP configuration:
interface wlan0_sta
#static ip_address=192.168.0.10/24
#static routers=192.168.0.1
#static domain_name_servers=192.168.0.1 8.8.8.8

# It is possible to fall back to a static IP if DHCP fails:
# define static profile
#profile static_eth0
#static ip_address=192.168.1.23/24
#static routers=192.168.1.1
#static domain_name_servers=192.168.1.1

# fallback to static profile on eth0
#interface eth0
#fallback static_eth0
EOF
CHROOTEOF

chmod 755 $NEWROOT/tasks
chroot $NEWROOT ./tasks

# Now, umount any previous mount
ARGS="dev/pts dev proc sys etc/resolv.conf /var/run/ root"
# mount the virtual filesystems & resolv.conf to enable the network
for i in $ARGS; do
  umount $NEWROOT/$i
done
umount $NEWBOOT
umount $NEWROOT
